/private/var/tmp/_bazel_youbin.jia/427307179cebeb18bd7a072aac1aa589/execroot/binary_tree/src/binary_tree.h:
    1|       |#ifndef BINARY_TREE_H
    2|       |#define BINARY_TREE_H
    3|       |
    4|       |#include <memory>
    5|       |#include <vector>
    6|       |#include <stdexcept>
    7|       |#include <algorithm>
    8|       |#include <limits>
    9|       |
   10|       |template<typename T>
   11|       |struct TreeNode {
   12|       |    T data;
   13|       |    std::unique_ptr<TreeNode<T>> left;
   14|       |    std::unique_ptr<TreeNode<T>> right;
   15|       |    
   16|     67|    TreeNode(const T& value) : data(value), left(nullptr), right(nullptr) {}
   17|       |};
   18|       |
   19|       |template<typename T>
   20|       |class BinaryTree {
   21|       |private:
   22|       |    std::unique_ptr<TreeNode<T>> root;
   23|       |    size_t size_;
   24|       |    
   25|       |    // Helper functions
   26|       |    void insertRecursive(std::unique_ptr<TreeNode<T>>& node, const T& value);
   27|       |    bool searchRecursive(const std::unique_ptr<TreeNode<T>>& node, const T& value) const;
   28|       |    void inorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const;
   29|       |    void preorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const;
   30|       |    void postorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const;
   31|       |    int getHeightRecursive(const std::unique_ptr<TreeNode<T>>& node) const;
   32|       |    int getDepthRecursive(const std::unique_ptr<TreeNode<T>>& node, const T& value, int depth) const;
   33|       |    std::unique_ptr<TreeNode<T>> findMinRecursive(std::unique_ptr<TreeNode<T>>& node);
   34|       |    std::unique_ptr<TreeNode<T>> removeRecursive(std::unique_ptr<TreeNode<T>>& node, const T& value);
   35|       |    void clearRecursive(std::unique_ptr<TreeNode<T>>& node);
   36|       |    bool isBalancedRecursive(const std::unique_ptr<TreeNode<T>>& node, int& height) const;
   37|       |    bool isBSTRecursive(const std::unique_ptr<TreeNode<T>>& node, T min_val, T max_val) const;
   38|       |
   39|       |public:
   40|     18|    BinaryTree() : root(nullptr), size_(0) {}
  ------------------
  | _ZN10BinaryTreeIiEC2Ev:
  |   40|     17|    BinaryTree() : root(nullptr), size_(0) {}
  ------------------
  | _ZN10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEEC2Ev:
  |   40|      1|    BinaryTree() : root(nullptr), size_(0) {}
  ------------------
   41|     18|    ~BinaryTree() = default;
  ------------------
  | _ZN10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEED2Ev:
  |   41|      1|    ~BinaryTree() = default;
  ------------------
  | _ZN10BinaryTreeIiED2Ev:
  |   41|     17|    ~BinaryTree() = default;
  ------------------
   42|       |    
   43|       |    // Basic operations
   44|       |    void insert(const T& value);
   45|       |    bool search(const T& value) const;
   46|       |    bool remove(const T& value);
   47|       |    void clear();
   48|       |    
   49|       |    // Traversal methods
   50|       |    std::vector<T> inorder() const;
   51|       |    std::vector<T> preorder() const;
   52|       |    std::vector<T> postorder() const;
   53|       |    
   54|       |    // Tree properties
   55|     15|    size_t getSize() const { return size_; }
  ------------------
  | _ZNK10BinaryTreeIiE7getSizeEv:
  |   55|     14|    size_t getSize() const { return size_; }
  ------------------
  | _ZNK10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEE7getSizeEv:
  |   55|      1|    size_t getSize() const { return size_; }
  ------------------
   56|      5|    bool isEmpty() const { return root == nullptr; }
   57|       |    int getHeight() const;
   58|       |    int getDepth(const T& value) const;
   59|       |    T getMin() const;
   60|       |    T getMax() const;
   61|       |    
   62|       |    // Tree validation
   63|       |    bool isBalanced() const;
   64|       |    bool isBST() const;
   65|       |    
   66|       |    // Utility methods
   67|      3|    bool contains(const T& value) const { return search(value); }
   68|      2|    void add(const T& value) { insert(value); }
   69|       |};
   70|       |
   71|       |// Implementation
   72|       |template<typename T>
   73|    191|void BinaryTree<T>::insertRecursive(std::unique_ptr<TreeNode<T>>& node, const T& value) {
   74|    191|    if (!node) {
   75|     67|        node = std::make_unique<TreeNode<T>>(value);
   76|     67|        size_++;
   77|     67|        return;
   78|     67|    }
   79|       |    
   80|    124|    if (value < node->data) {
   81|     52|        insertRecursive(node->left, value);
   82|     72|    } else if (value > node->data) {
   83|     62|        insertRecursive(node->right, value);
   84|     62|    }
   85|       |    // If value == node->data, do nothing (duplicate)
   86|    124|}
  ------------------
  | _ZN10BinaryTreeIiE15insertRecursiveERNSt3__110unique_ptrI8TreeNodeIiENS1_14default_deleteIS4_EEEERKi:
  |   73|    185|void BinaryTree<T>::insertRecursive(std::unique_ptr<TreeNode<T>>& node, const T& value) {
  |   74|    185|    if (!node) {
  |   75|     64|        node = std::make_unique<TreeNode<T>>(value);
  |   76|     64|        size_++;
  |   77|     64|        return;
  |   78|     64|    }
  |   79|       |    
  |   80|    121|    if (value < node->data) {
  |   81|     52|        insertRecursive(node->left, value);
  |   82|     69|    } else if (value > node->data) {
  |   83|     59|        insertRecursive(node->right, value);
  |   84|     59|    }
  |   85|       |    // If value == node->data, do nothing (duplicate)
  |   86|    121|}
  ------------------
  | _ZN10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEE15insertRecursiveERNS0_10unique_ptrI8TreeNodeIS6_ENS0_14default_deleteISA_EEEERKS6_:
  |   73|      6|void BinaryTree<T>::insertRecursive(std::unique_ptr<TreeNode<T>>& node, const T& value) {
  |   74|      6|    if (!node) {
  |   75|      3|        node = std::make_unique<TreeNode<T>>(value);
  |   76|      3|        size_++;
  |   77|      3|        return;
  |   78|      3|    }
  |   79|       |    
  |   80|      3|    if (value < node->data) {
  |   81|      0|        insertRecursive(node->left, value);
  |   82|      3|    } else if (value > node->data) {
  |   83|      3|        insertRecursive(node->right, value);
  |   84|      3|    }
  |   85|       |    // If value == node->data, do nothing (duplicate)
  |   86|      3|}
  ------------------
   87|       |
   88|       |template<typename T>
   89|     77|void BinaryTree<T>::insert(const T& value) {
   90|     77|    insertRecursive(root, value);
   91|     77|}
  ------------------
  | _ZN10BinaryTreeIiE6insertERKi:
  |   89|     74|void BinaryTree<T>::insert(const T& value) {
  |   90|     74|    insertRecursive(root, value);
  |   91|     74|}
  ------------------
  | _ZN10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEE6insertERKS6_:
  |   89|      3|void BinaryTree<T>::insert(const T& value) {
  |   90|      3|    insertRecursive(root, value);
  |   91|      3|}
  ------------------
   92|       |
   93|       |template<typename T>
   94|    112|bool BinaryTree<T>::searchRecursive(const std::unique_ptr<TreeNode<T>>& node, const T& value) const {
   95|    112|    if (!node) {
   96|     14|        return false;
   97|     14|    }
   98|       |    
   99|     98|    if (value == node->data) {
  100|     26|        return true;
  101|     72|    } else if (value < node->data) {
  102|     30|        return searchRecursive(node->left, value);
  103|     42|    } else {
  104|     42|        return searchRecursive(node->right, value);
  105|     42|    }
  106|     98|}
  ------------------
  | _ZNK10BinaryTreeIiE15searchRecursiveERKNSt3__110unique_ptrI8TreeNodeIiENS1_14default_deleteIS4_EEEERKi:
  |   94|    105|bool BinaryTree<T>::searchRecursive(const std::unique_ptr<TreeNode<T>>& node, const T& value) const {
  |   95|    105|    if (!node) {
  |   96|     13|        return false;
  |   97|     13|    }
  |   98|       |    
  |   99|     92|    if (value == node->data) {
  |  100|     24|        return true;
  |  101|     68|    } else if (value < node->data) {
  |  102|     30|        return searchRecursive(node->left, value);
  |  103|     38|    } else {
  |  104|     38|        return searchRecursive(node->right, value);
  |  105|     38|    }
  |  106|     92|}
  ------------------
  | _ZNK10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEE15searchRecursiveERKNS0_10unique_ptrI8TreeNodeIS6_ENS0_14default_deleteISA_EEEERKS6_:
  |   94|      7|bool BinaryTree<T>::searchRecursive(const std::unique_ptr<TreeNode<T>>& node, const T& value) const {
  |   95|      7|    if (!node) {
  |   96|      1|        return false;
  |   97|      1|    }
  |   98|       |    
  |   99|      6|    if (value == node->data) {
  |  100|      2|        return true;
  |  101|      4|    } else if (value < node->data) {
  |  102|      0|        return searchRecursive(node->left, value);
  |  103|      4|    } else {
  |  104|      4|        return searchRecursive(node->right, value);
  |  105|      4|    }
  |  106|      6|}
  ------------------
  107|       |
  108|       |template<typename T>
  109|     40|bool BinaryTree<T>::search(const T& value) const {
  110|     40|    return searchRecursive(root, value);
  111|     40|}
  ------------------
  | _ZNK10BinaryTreeIiE6searchERKi:
  |  109|     37|bool BinaryTree<T>::search(const T& value) const {
  |  110|     37|    return searchRecursive(root, value);
  |  111|     37|}
  ------------------
  | _ZNK10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEE6searchERKS6_:
  |  109|      3|bool BinaryTree<T>::search(const T& value) const {
  |  110|      3|    return searchRecursive(root, value);
  |  111|      3|}
  ------------------
  112|       |
  113|       |template<typename T>
  114|     49|void BinaryTree<T>::inorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const {
  115|     49|    if (node) {
  116|     23|        inorderTraversal(node->left, result);
  117|     23|        result.push_back(node->data);
  118|     23|        inorderTraversal(node->right, result);
  119|     23|    }
  120|     49|}
  ------------------
  | _ZNK10BinaryTreeIiE16inorderTraversalERKNSt3__110unique_ptrI8TreeNodeIiENS1_14default_deleteIS4_EEEERNS1_6vectorIiNS1_9allocatorIiEEEE:
  |  114|     42|void BinaryTree<T>::inorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const {
  |  115|     42|    if (node) {
  |  116|     20|        inorderTraversal(node->left, result);
  |  117|     20|        result.push_back(node->data);
  |  118|     20|        inorderTraversal(node->right, result);
  |  119|     20|    }
  |  120|     42|}
  ------------------
  | _ZNK10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEE16inorderTraversalERKNS0_10unique_ptrI8TreeNodeIS6_ENS0_14default_deleteISA_EEEERNS0_6vectorIS6_NS4_IS6_EEEE:
  |  114|      7|void BinaryTree<T>::inorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const {
  |  115|      7|    if (node) {
  |  116|      3|        inorderTraversal(node->left, result);
  |  117|      3|        result.push_back(node->data);
  |  118|      3|        inorderTraversal(node->right, result);
  |  119|      3|    }
  |  120|      7|}
  ------------------
  121|       |
  122|       |template<typename T>
  123|      3|std::vector<T> BinaryTree<T>::inorder() const {
  124|      3|    std::vector<T> result;
  125|      3|    inorderTraversal(root, result);
  126|      3|    return result;
  127|      3|}
  ------------------
  | _ZNK10BinaryTreeIiE7inorderEv:
  |  123|      2|std::vector<T> BinaryTree<T>::inorder() const {
  |  124|      2|    std::vector<T> result;
  |  125|      2|    inorderTraversal(root, result);
  |  126|      2|    return result;
  |  127|      2|}
  ------------------
  | _ZNK10BinaryTreeINSt3__112basic_stringIcNS0_11char_traitsIcEENS0_9allocatorIcEEEEE7inorderEv:
  |  123|      1|std::vector<T> BinaryTree<T>::inorder() const {
  |  124|      1|    std::vector<T> result;
  |  125|      1|    inorderTraversal(root, result);
  |  126|      1|    return result;
  |  127|      1|}
  ------------------
  128|       |
  129|       |template<typename T>
  130|     11|void BinaryTree<T>::preorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const {
  131|     11|    if (node) {
  132|      5|        result.push_back(node->data);
  133|      5|        preorderTraversal(node->left, result);
  134|      5|        preorderTraversal(node->right, result);
  135|      5|    }
  136|     11|}
  137|       |
  138|       |template<typename T>
  139|      1|std::vector<T> BinaryTree<T>::preorder() const {
  140|      1|    std::vector<T> result;
  141|      1|    preorderTraversal(root, result);
  142|      1|    return result;
  143|      1|}
  144|       |
  145|       |template<typename T>
  146|     11|void BinaryTree<T>::postorderTraversal(const std::unique_ptr<TreeNode<T>>& node, std::vector<T>& result) const {
  147|     11|    if (node) {
  148|      5|        postorderTraversal(node->left, result);
  149|      5|        postorderTraversal(node->right, result);
  150|      5|        result.push_back(node->data);
  151|      5|    }
  152|     11|}
  153|       |
  154|       |template<typename T>
  155|      1|std::vector<T> BinaryTree<T>::postorder() const {
  156|      1|    std::vector<T> result;
  157|      1|    postorderTraversal(root, result);
  158|      1|    return result;
  159|      1|}
  160|       |
  161|       |template<typename T>
  162|     58|int BinaryTree<T>::getHeightRecursive(const std::unique_ptr<TreeNode<T>>& node) const {
  163|     58|    if (!node) {
  164|     33|        return -1;
  165|     33|    }
  166|       |    
  167|     25|    int leftHeight = getHeightRecursive(node->left);
  168|     25|    int rightHeight = getHeightRecursive(node->right);
  169|       |    
  170|     25|    return std::max(leftHeight, rightHeight) + 1;
  171|     58|}
  172|       |
  173|       |template<typename T>
  174|      8|int BinaryTree<T>::getHeight() const {
  175|      8|    return getHeightRecursive(root);
  176|      8|}
  177|       |
  178|       |template<typename T>
  179|     17|int BinaryTree<T>::getDepthRecursive(const std::unique_ptr<TreeNode<T>>& node, const T& value, int depth) const {
  180|     17|    if (!node) {
  181|      2|        return -1;
  182|      2|    }
  183|       |    
  184|     15|    if (value == node->data) {
  185|      6|        return depth;
  186|      9|    } else if (value < node->data) {
  187|      3|        return getDepthRecursive(node->left, value, depth + 1);
  188|      6|    } else {
  189|      6|        return getDepthRecursive(node->right, value, depth + 1);
  190|      6|    }
  191|     15|}
  192|       |
  193|       |template<typename T>
  194|      8|int BinaryTree<T>::getDepth(const T& value) const {
  195|      8|    return getDepthRecursive(root, value, 0);
  196|      8|}
  197|       |
  198|       |template<typename T>
  199|      4|T BinaryTree<T>::getMin() const {
  200|      4|    if (!root) {
  201|      1|        throw std::runtime_error("Tree is empty");
  202|      1|    }
  203|       |    
  204|      3|    TreeNode<T>* current = root.get();
  205|      6|    while (current->left) {
  206|      3|        current = current->left.get();
  207|      3|    }
  208|      3|    return current->data;
  209|      4|}
  210|       |
  211|       |template<typename T>
  212|      4|T BinaryTree<T>::getMax() const {
  213|      4|    if (!root) {
  214|      1|        throw std::runtime_error("Tree is empty");
  215|      1|    }
  216|       |    
  217|      3|    TreeNode<T>* current = root.get();
  218|      5|    while (current->right) {
  219|      2|        current = current->right.get();
  220|      2|    }
  221|      3|    return current->data;
  222|      4|}
  223|       |
  224|       |template<typename T>
  225|      0|std::unique_ptr<TreeNode<T>> BinaryTree<T>::findMinRecursive(std::unique_ptr<TreeNode<T>>& node) {
  226|      0|    if (!node->left) {
  227|      0|        return std::move(node);
  228|      0|    }
  229|      0|    return findMinRecursive(node->left);
  230|      0|}
  231|       |
  232|       |template<typename T>
  233|      5|std::unique_ptr<TreeNode<T>> BinaryTree<T>::removeRecursive(std::unique_ptr<TreeNode<T>>& node, const T& value) {
  234|      5|    if (!node) {
  235|      1|        return nullptr;
  236|      1|    }
  237|       |    
  238|      4|    if (value < node->data) {
  239|      1|        node->left = removeRecursive(node->left, value);
  240|      3|    } else if (value > node->data) {
  241|      2|        node->right = removeRecursive(node->right, value);
  242|      2|    } else {
  243|       |        // Node to delete found
  244|      1|        if (!node->left) {
  245|      1|            size_--;
  246|      1|            return std::move(node->right);
  247|      1|        } else if (!node->right) {
  248|      0|            size_--;
  249|      0|            return std::move(node->left);
  250|      0|        } else {
  251|       |            // Node has two children
  252|      0|            auto successor = findMinRecursive(node->right);
  253|      0|            node->data = successor->data;
  254|      0|            node->right = removeRecursive(node->right, successor->data);
  255|      0|        }
  256|      1|    }
  257|      3|    return std::move(node);
  258|      4|}
  259|       |
  260|       |template<typename T>
  261|      2|bool BinaryTree<T>::remove(const T& value) {
  262|      2|    size_t originalSize = size_;
  263|      2|    root = removeRecursive(root, value);
  264|      2|    return size_ < originalSize;
  265|      2|}
  266|       |
  267|       |template<typename T>
  268|     24|void BinaryTree<T>::clearRecursive(std::unique_ptr<TreeNode<T>>& node) {
  269|     24|    if (node) {
  270|      3|        clearRecursive(node->left);
  271|      3|        clearRecursive(node->right);
  272|      3|        node.reset();
  273|      3|    }
  274|     24|}
  275|       |
  276|       |template<typename T>
  277|     18|void BinaryTree<T>::clear() {
  278|     18|    clearRecursive(root);
  279|     18|    size_ = 0;
  280|     18|}
  281|       |
  282|       |template<typename T>
  283|       |bool BinaryTree<T>::isBalancedRecursive(const std::unique_ptr<TreeNode<T>>& node, int& height) const {
  284|       |    if (!node) {
  285|       |        height = -1;
  286|       |        return true;
  287|       |    }
  288|       |    
  289|       |    int leftHeight, rightHeight;
  290|       |    bool leftBalanced = isBalancedRecursive(node->left, leftHeight);
  291|       |    bool rightBalanced = isBalancedRecursive(node->right, rightHeight);
  292|       |    
  293|       |    height = std::max(leftHeight, rightHeight) + 1;
  294|       |    
  295|       |    return leftBalanced && rightBalanced && 
  296|       |           std::abs(leftHeight - rightHeight) <= 1;
  297|       |}
  298|       |
  299|       |template<typename T>
  300|       |bool BinaryTree<T>::isBalanced() const {
  301|       |    int height;
  302|       |    return isBalancedRecursive(root, height);
  303|       |}
  304|       |
  305|       |template<typename T>
  306|       |bool BinaryTree<T>::isBSTRecursive(const std::unique_ptr<TreeNode<T>>& node, T min_val, T max_val) const {
  307|       |    if (!node) {
  308|       |        return true;
  309|       |    }
  310|       |    
  311|       |    if (node->data <= min_val || node->data >= max_val) {
  312|       |        return false;
  313|       |    }
  314|       |    
  315|       |    return isBSTRecursive(node->left, min_val, node->data) &&
  316|       |           isBSTRecursive(node->right, node->data, max_val);
  317|       |}
  318|       |
  319|       |template<typename T>
  320|       |bool BinaryTree<T>::isBST() const {
  321|       |    if (!root) {
  322|       |        return true;
  323|       |    }
  324|       |    
  325|       |    T min_val = std::numeric_limits<T>::lowest();
  326|       |    T max_val = std::numeric_limits<T>::max();
  327|       |    
  328|       |    return isBSTRecursive(root->left, min_val, root->data) &&
  329|       |           isBSTRecursive(root->right, root->data, max_val);
  330|       |}
  331|       |
  332|       |#endif // BINARY_TREE_H 

/private/var/tmp/_bazel_youbin.jia/427307179cebeb18bd7a072aac1aa589/execroot/binary_tree/test/binary_tree_test.cc:
    1|       |#include <gtest/gtest.h>
    2|       |#include "../src/binary_tree.h"
    3|       |#include <vector>
    4|       |#include <algorithm>
    5|       |
    6|       |class BinaryTreeTest : public ::testing::Test {
    7|       |protected:
    8|       |    BinaryTree<int> tree;
    9|       |    
   10|     17|    void SetUp() override {
   11|     17|        tree.clear();
   12|     17|    }
   13|       |};
   14|       |
   15|       |// Test basic insertion and search
   16|      1|TEST_F(BinaryTreeTest, InsertAndSearch) {
   17|      1|    EXPECT_TRUE(tree.isEmpty());
   18|      1|    EXPECT_EQ(tree.getSize(), 0);
   19|       |    
   20|      1|    tree.insert(5);
   21|      1|    EXPECT_FALSE(tree.isEmpty());
   22|      1|    EXPECT_EQ(tree.getSize(), 1);
   23|      1|    EXPECT_TRUE(tree.search(5));
   24|      1|    EXPECT_FALSE(tree.search(3));
   25|       |    
   26|      1|    tree.insert(3);
   27|      1|    tree.insert(7);
   28|      1|    EXPECT_EQ(tree.getSize(), 3);
   29|      1|    EXPECT_TRUE(tree.search(3));
   30|      1|    EXPECT_TRUE(tree.search(7));
   31|      1|    EXPECT_FALSE(tree.search(10));
   32|      1|}
   33|       |
   34|       |// Test duplicate insertion
   35|      1|TEST_F(BinaryTreeTest, DuplicateInsertion) {
   36|      1|    tree.insert(5);
   37|      1|    tree.insert(5);  // Duplicate
   38|      1|    EXPECT_EQ(tree.getSize(), 1);  // Should not increase size
   39|      1|    EXPECT_TRUE(tree.search(5));
   40|      1|}
   41|       |
   42|       |// Test traversal methods
   43|      1|TEST_F(BinaryTreeTest, InorderTraversal) {
   44|      1|    tree.insert(5);
   45|      1|    tree.insert(3);
   46|      1|    tree.insert(7);
   47|      1|    tree.insert(1);
   48|      1|    tree.insert(9);
   49|       |    
   50|      1|    std::vector<int> expected = {1, 3, 5, 7, 9};
   51|      1|    std::vector<int> result = tree.inorder();
   52|      1|    EXPECT_EQ(result, expected);
   53|      1|}
   54|       |
   55|      1|TEST_F(BinaryTreeTest, PreorderTraversal) {
   56|      1|    tree.insert(5);
   57|      1|    tree.insert(3);
   58|      1|    tree.insert(7);
   59|      1|    tree.insert(1);
   60|      1|    tree.insert(9);
   61|       |    
   62|      1|    std::vector<int> result = tree.preorder();
   63|      1|    EXPECT_EQ(result.size(), 5);
   64|      1|    EXPECT_EQ(result[0], 5);  // Root should be first
   65|      1|}
   66|       |
   67|      1|TEST_F(BinaryTreeTest, PostorderTraversal) {
   68|      1|    tree.insert(5);
   69|      1|    tree.insert(3);
   70|      1|    tree.insert(7);
   71|      1|    tree.insert(1);
   72|      1|    tree.insert(9);
   73|       |    
   74|      1|    std::vector<int> result = tree.postorder();
   75|      1|    EXPECT_EQ(result.size(), 5);
   76|      1|    EXPECT_EQ(result[4], 5);  // Root should be last
   77|      1|}
   78|       |
   79|       |// Test tree properties
   80|      1|TEST_F(BinaryTreeTest, TreeHeight) {
   81|      1|    EXPECT_EQ(tree.getHeight(), -1);  // Empty tree
   82|       |    
   83|      1|    tree.insert(5);
   84|      1|    EXPECT_EQ(tree.getHeight(), 0);  // Single node
   85|       |    
   86|      1|    tree.insert(3);
   87|      1|    tree.insert(7);
   88|      1|    EXPECT_EQ(tree.getHeight(), 1);  // Two levels
   89|       |    
   90|      1|    tree.insert(1);
   91|      1|    tree.insert(9);
   92|      1|    EXPECT_EQ(tree.getHeight(), 2);  // Three levels
   93|      1|}
   94|       |
   95|      1|TEST_F(BinaryTreeTest, NodeDepth) {
   96|      1|    tree.insert(5);
   97|      1|    tree.insert(3);
   98|      1|    tree.insert(7);
   99|      1|    tree.insert(1);
  100|      1|    tree.insert(9);
  101|       |    
  102|      1|    EXPECT_EQ(tree.getDepth(5), 0);  // Root
  103|      1|    EXPECT_EQ(tree.getDepth(3), 1);  // Level 1
  104|      1|    EXPECT_EQ(tree.getDepth(7), 1);  // Level 1
  105|      1|    EXPECT_EQ(tree.getDepth(1), 2);  // Level 2
  106|      1|    EXPECT_EQ(tree.getDepth(9), 2);  // Level 2
  107|      1|    EXPECT_EQ(tree.getDepth(10), -1);  // Not found
  108|      1|}
  109|       |
  110|      1|TEST_F(BinaryTreeTest, MinMaxValues) {
  111|      1|    tree.insert(5);
  112|      1|    tree.insert(3);
  113|      1|    tree.insert(7);
  114|      1|    tree.insert(1);
  115|      1|    tree.insert(9);
  116|       |    
  117|      1|    EXPECT_EQ(tree.getMin(), 1);
  118|      1|    EXPECT_EQ(tree.getMax(), 9);
  119|      1|}
  120|       |
  121|       |// Test edge cases
  122|      1|TEST_F(BinaryTreeTest, EmptyTreeOperations) {
  123|      1|    EXPECT_TRUE(tree.isEmpty());
  124|      1|    EXPECT_EQ(tree.getSize(), 0);
  125|      1|    EXPECT_EQ(tree.getHeight(), -1);
  126|      1|    EXPECT_FALSE(tree.search(5));
  127|      1|    EXPECT_EQ(tree.getDepth(5), -1);
  128|       |    
  129|      1|    EXPECT_THROW(tree.getMin(), std::runtime_error);
  130|      1|    EXPECT_THROW(tree.getMax(), std::runtime_error);
  131|      1|}
  132|       |
  133|      1|TEST_F(BinaryTreeTest, SingleNodeTree) {
  134|      1|    tree.insert(5);
  135|       |    
  136|      1|    EXPECT_FALSE(tree.isEmpty());
  137|      1|    EXPECT_EQ(tree.getSize(), 1);
  138|      1|    EXPECT_EQ(tree.getHeight(), 0);
  139|      1|    EXPECT_TRUE(tree.search(5));
  140|      1|    EXPECT_FALSE(tree.search(3));
  141|      1|    EXPECT_EQ(tree.getDepth(5), 0);
  142|      1|    EXPECT_EQ(tree.getMin(), 5);
  143|      1|    EXPECT_EQ(tree.getMax(), 5);
  144|      1|}
  145|       |
  146|       |// Test utility methods
  147|      1|TEST_F(BinaryTreeTest, ContainsMethod) {
  148|      1|    tree.insert(5);
  149|      1|    tree.insert(3);
  150|       |    
  151|      1|    EXPECT_TRUE(tree.contains(5));
  152|      1|    EXPECT_TRUE(tree.contains(3));
  153|      1|    EXPECT_FALSE(tree.contains(7));
  154|      1|}
  155|       |
  156|      1|TEST_F(BinaryTreeTest, AddMethod) {
  157|      1|    tree.add(5);
  158|      1|    tree.add(3);
  159|       |    
  160|      1|    EXPECT_EQ(tree.getSize(), 2);
  161|      1|    EXPECT_TRUE(tree.search(5));
  162|      1|    EXPECT_TRUE(tree.search(3));
  163|      1|}
  164|       |
  165|       |// Test remove functionality
  166|      1|TEST_F(BinaryTreeTest, RemoveOperation) {
  167|      1|    tree.insert(5);
  168|      1|    tree.insert(3);
  169|      1|    tree.insert(7);
  170|       |    
  171|      1|    EXPECT_TRUE(tree.remove(3));
  172|      1|    EXPECT_EQ(tree.getSize(), 2);
  173|      1|    EXPECT_FALSE(tree.search(3));
  174|       |    
  175|      1|    EXPECT_FALSE(tree.remove(10));  // Non-existent value
  176|      1|    EXPECT_EQ(tree.getSize(), 2);
  177|      1|}
  178|       |
  179|       |// Test clear functionality
  180|      1|TEST_F(BinaryTreeTest, ClearOperation) {
  181|      1|    tree.insert(5);
  182|      1|    tree.insert(3);
  183|      1|    tree.insert(7);
  184|       |    
  185|      1|    EXPECT_EQ(tree.getSize(), 3);
  186|      1|    tree.clear();
  187|       |    
  188|      1|    EXPECT_TRUE(tree.isEmpty());
  189|      1|    EXPECT_EQ(tree.getSize(), 0);
  190|      1|    EXPECT_EQ(tree.getHeight(), -1);
  191|      1|    EXPECT_FALSE(tree.search(5));
  192|      1|}
  193|       |
  194|       |// Test with different data types
  195|      1|TEST_F(BinaryTreeTest, StringTree) {
  196|      1|    BinaryTree<std::string> stringTree;
  197|       |    
  198|      1|    stringTree.insert("apple");
  199|      1|    stringTree.insert("banana");
  200|      1|    stringTree.insert("cherry");
  201|       |    
  202|      1|    EXPECT_EQ(stringTree.getSize(), 3);
  203|      1|    EXPECT_TRUE(stringTree.search("apple"));
  204|      1|    EXPECT_TRUE(stringTree.search("banana"));
  205|      1|    EXPECT_FALSE(stringTree.search("orange"));
  206|       |    
  207|      1|    std::vector<std::string> expected = {"apple", "banana", "cherry"};
  208|      1|    std::vector<std::string> result = stringTree.inorder();
  209|      1|    EXPECT_EQ(result, expected);
  210|      1|}
  211|       |
  212|       |// Test complex tree structure
  213|      1|TEST_F(BinaryTreeTest, ComplexTreeStructure) {
  214|       |    // Create a more complex tree
  215|      1|    tree.insert(10);
  216|      1|    tree.insert(5);
  217|      1|    tree.insert(15);
  218|      1|    tree.insert(3);
  219|      1|    tree.insert(7);
  220|      1|    tree.insert(12);
  221|      1|    tree.insert(18);
  222|      1|    tree.insert(1);
  223|      1|    tree.insert(4);
  224|      1|    tree.insert(6);
  225|      1|    tree.insert(8);
  226|      1|    tree.insert(11);
  227|      1|    tree.insert(13);
  228|      1|    tree.insert(16);
  229|      1|    tree.insert(20);
  230|       |    
  231|      1|    EXPECT_EQ(tree.getSize(), 15);
  232|      1|    EXPECT_EQ(tree.getHeight(), 3);
  233|       |    
  234|       |    // Test all values are present
  235|      1|    std::vector<int> values = {1, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 15, 16, 18, 20};
  236|     15|    for (int value : values) {
  237|     30|        EXPECT_TRUE(tree.search(value)) << "Value " << value << " should be found";
  238|     15|    }
  239|       |    
  240|       |    // Test non-existent values
  241|      1|    std::vector<int> nonValues = {2, 9, 14, 17, 19, 21};
  242|      6|    for (int value : nonValues) {
  243|     12|        EXPECT_FALSE(tree.search(value)) << "Value " << value << " should not be found";
  244|      6|    }
  245|       |    
  246|       |    // Test inorder traversal
  247|      1|    std::vector<int> result = tree.inorder();
  248|      1|    EXPECT_EQ(result, values);
  249|      1|}
  250|       |
  251|       |// Test boundary conditions
  252|      1|TEST_F(BinaryTreeTest, BoundaryConditions) {
  253|       |    // Test with large numbers
  254|      1|    tree.insert(1000000);
  255|      1|    tree.insert(-1000000);
  256|      1|    tree.insert(0);
  257|       |    
  258|      1|    EXPECT_EQ(tree.getSize(), 3);
  259|      1|    EXPECT_EQ(tree.getMin(), -1000000);
  260|      1|    EXPECT_EQ(tree.getMax(), 1000000);
  261|       |    
  262|       |    // Test with repeated operations
  263|     11|    for (int i = 0; i < 10; i++) {
  264|     10|        tree.insert(5);
  265|     10|    }
  266|      1|    EXPECT_EQ(tree.getSize(), 4);  // Should not increase due to duplicates
  267|      1|}
  268|       |
  269|      1|int main(int argc, char **argv) {
  270|      1|    ::testing::InitGoogleTest(&argc, argv);
  271|      1|    return RUN_ALL_TESTS();
  272|      1|} 

